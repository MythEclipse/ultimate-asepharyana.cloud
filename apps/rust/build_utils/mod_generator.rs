use crate::build_utils::handler_updater::{update_handler_file, HandlerRouteInfo};
use crate::build_utils::path_utils::{
    compute_module_path_prefix, is_dynamic_route_content, sanitize_module_name,
};
use anyhow::{Context, Result};
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};

fn process_directory_entries(
    current_dir: &Path,
    root_api_path: &Path,
    module_path_prefix: &str,
    all_handlers: &mut Vec<HandlerRouteInfo>,
    all_schemas: &mut HashSet<String>,
    modules: &mut Vec<String>,
    pub_mods: &mut Vec<String>,
    route_registrations: &mut Vec<String>,
) -> Result<()> {
    let mut entries: Vec<PathBuf> = fs::read_dir(current_dir)
        .with_context(|| format!("Failed to read directory: {:?}", current_dir))?
        .filter_map(Result::ok)
        .map(|e| e.path())
        .collect();
    entries.sort();

    for path in entries {
        let file_name = path.file_name().and_then(|s| s.to_str()).unwrap_or("");
        if file_name.starts_with('.')
            || file_name == "mod.rs"
            || file_name == "test"
            || file_name == "chat"
        {
            continue;
        }

        let mod_name = sanitize_module_name(file_name);

        if path.is_dir() {
            // Recursively generate mod.rs for the subdirectory
            let has_routes = generate_mod_for_directory(
                &path,
                root_api_path,
                all_handlers,
                all_schemas,
                modules,
            )?;

            if has_routes {
                pub_mods.push(format!("pub mod {};", mod_name));
                route_registrations.push(mod_name.clone());

                // If this is the root level, add to modules
                if current_dir == root_api_path {
                    modules.push(mod_name.clone());
                }
            }
        } else if path.is_file() && path.extension().is_some_and(|e| e == "rs") {
            let file_content = fs::read_to_string(&path)?;

            let file_stem = path
                .file_stem()
                .and_then(|s| s.to_str())
                .ok_or_else(|| anyhow::anyhow!("Invalid file stem for: {:?}", path))?;

            let mod_name_from_file_stem = sanitize_module_name(file_stem);

            let is_index_file = file_stem == "index";
            let is_dynamic = is_dynamic_route_content(&file_content);

            pub_mods.push(format!("pub mod {};", mod_name_from_file_stem));

            // For dynamic routes, register the route using the dynamic segment
            if is_dynamic {
                route_registrations.push(format!(
                    "{}/{{{}}}",
                    current_dir
                        .strip_prefix(root_api_path)?
                        .to_str()
                        .unwrap()
                        .replace("\\", "/"),
                    file_stem
                ));
            } else if is_index_file {
                // For index.rs, register the full module path
                route_registrations.push(format!(
                    "{}::{}",
                    module_path_prefix, mod_name_from_file_stem
                ));
            } else {
                route_registrations.push(mod_name_from_file_stem.clone());
            }

            if let Some(handler_info) =
                update_handler_file(&path, all_schemas, module_path_prefix, root_api_path)
                    .with_context(|| format!("Failed to update handler file: {:?}", path))?
            {
                all_handlers.push(handler_info);
            }

            // If this is the root level and not an index file, add to modules
            if current_dir == root_api_path && !is_index_file {
                modules.push(mod_name_from_file_stem.clone());
            }
        }
    }

    Ok(())
}

fn build_route_registration_body(route_registrations: &[String]) -> String {
    if route_registrations.is_empty() {
        "router".to_string()
    } else {
        let mut reversed_registrations: Vec<String> = route_registrations.to_vec();
        reversed_registrations.reverse();

        reversed_registrations
            .into_iter()
            .fold("router".to_string(), |acc, reg| {
                // If it's a direct path (like "anime/detail/{slug}"), format it differently
                if reg.contains("::") {
                    // Check if it's a full module path (e.g., crate::routes::api::anime::index)
                    format!("{}::register_routes({})", reg, acc)
                } else {
                    // It's a module name (e.g., product_list)
                    format!("{}::register_routes({})", reg, acc)
                }
            })
    }
}

fn generate_mod_content(pub_mods: &[String], body: &str) -> String {
    format!(
        r#"/// THIS FILE IS AUTOMATICALLY GENERATED BY build.rs
/// DO NOT EDIT THIS FILE MANUALLY

{}

/// Register routes for this directory
use axum::Router;
use std::sync::Arc;
use crate::routes::AppState;
pub fn register_routes(router: Router<Arc<AppState>>) -> Router<Arc<AppState>> {{
  {}
}}
"#,
        pub_mods.join("\n"),
        body
    )
}

fn cleanup_empty_directory(
    current_dir: &Path,
    root_api_path: &Path,
    has_routes: bool,
) -> Result<()> {
    // If this directory has no routes and is not the root, delete it
    if !has_routes && current_dir != root_api_path {
        fs::remove_dir_all(current_dir)
            .with_context(|| format!("Failed to remove empty directory: {:?}", current_dir))?;
    }
    Ok(())
}

pub fn generate_mod_for_directory(
    current_dir: &Path,
    root_api_path: &Path,
    all_handlers: &mut Vec<HandlerRouteInfo>,
    all_schemas: &mut HashSet<String>,
    modules: &mut Vec<String>,
) -> Result<bool> {
    let mut pub_mods = Vec::new();
    let mut route_registrations = Vec::new();

    let module_path_prefix = compute_module_path_prefix(current_dir, root_api_path)?;

    process_directory_entries(
        current_dir,
        root_api_path,
        &module_path_prefix,
        all_handlers,
        all_schemas,
        modules,
        &mut pub_mods,
        &mut route_registrations,
    )?;

    let body = build_route_registration_body(&route_registrations);
    let mod_content = generate_mod_content(&pub_mods, &body);

    fs::write(current_dir.join("mod.rs"), mod_content)
        .with_context(|| format!("Failed to write mod.rs for directory: {:?}", current_dir))?;

    let has_routes = !pub_mods.is_empty();

    cleanup_empty_directory(current_dir, root_api_path, has_routes)?;

    Ok(has_routes)
}
