use std::collections::HashSet;
use std::fs;
use std::path::{ Path, PathBuf };
use anyhow::Result;
use crate::build_utils::handler_updater::{ HandlerRouteInfo, update_handler_file };
use crate::build_utils::path_utils::is_dynamic_segment;
// Removed generate_handler_template as it's no longer directly called here

pub fn generate_mod_for_directory(
  current_dir: &Path,
  root_api_path: &Path,
  all_handlers: &mut Vec<HandlerRouteInfo>,
  all_schemas: &mut HashSet<String>
) -> Result<()> {
  let mut pub_mods = Vec::new();
  let mut route_registrations = Vec::new();

  let relative_path = current_dir.strip_prefix(root_api_path).unwrap_or(Path::new(""));
  let relative_path_str = relative_path
    .to_str()
    .unwrap()
    .replace(std::path::MAIN_SEPARATOR, "::")
    .replace('-', "_");

  let module_path_prefix = if relative_path_str.is_empty() {
    "crate::routes::api".to_string()
  } else {
    format!("crate::routes::api::{}", relative_path_str.replace("[", "").replace("]", ""))
  };

  let mut entries: Vec<PathBuf> = fs
    ::read_dir(current_dir)?
    .filter_map(Result::ok)
    .map(|e| e.path())
    .collect();
  entries.sort();

  for path in entries {
    let file_name = path
      .file_name()
      .and_then(|s| s.to_str())
      .unwrap_or("");
    if file_name.starts_with('.') || file_name == "mod.rs" {
      continue;
    }

    let is_dynamic = is_dynamic_segment(file_name);
    let mod_name_sanitized = file_name.trim_matches(|c| (c == '[' || c == ']')).replace('-', "_");

    if path.is_dir() {
      // Create mod.rs inside the dynamic segment directory
      if is_dynamic {
        fs::write(path.join("mod.rs"), b"pub mod index;\n")?;
      }

      pub_mods.push(format!("pub mod {};", mod_name_sanitized));

      // Recursively generate mod.rs for the subdirectory
      generate_mod_for_directory(&path, root_api_path, all_handlers, all_schemas)?;

      // Route registration for dynamic segments needs to point to the index.rs inside
      if is_dynamic {
        route_registrations.push(format!("{}::index", mod_name_sanitized));
      } else {
        route_registrations.push(format!("{}", mod_name_sanitized));
      }
    } else if path.is_file() && path.extension().map_or(false, |e| e == "rs") {
      let file_stem = path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap();

      let mod_name = file_stem.replace(['[', ']'], "").replace('-', "_");
      pub_mods.push(format!("pub mod {};", mod_name));
      route_registrations.push(format!("{}", mod_name));

      if
        let Some(handler_info) = update_handler_file(
          &path,
          all_schemas,
          &module_path_prefix,
          root_api_path
        )?
      {
        all_handlers.push(handler_info);
      }
    }
  }

  let mod_content = format!(
    r#"/// THIS FILE IS AUTOMATICALLY GENERATED BY build.rs
/// DO NOT EDIT THIS FILE MANUALLY

{}

/// Register routes for this directory
use axum::Router;
use std::sync::Arc;
use crate::routes::AppState;
pub fn register_routes(mut router: Router<Arc<AppState>>) -> Router<Arc<AppState>> {{
  {}
}}
"#,
    pub_mods.join("\n"),
    if route_registrations.is_empty() {
      "router".to_string()
    } else {
      route_registrations
        .iter()
        .rev()
        .fold("router".to_string(), |acc, reg| { format!("{}::register_routes({})", reg, acc) })
    }
  );

  fs::write(current_dir.join("mod.rs"), mod_content)?;
  Ok(())
}
