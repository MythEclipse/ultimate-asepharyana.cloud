use std::collections::HashSet;
use std::fs;
use std::path::{ Path, PathBuf };
use anyhow::Result;
use crate::build_utils::handler_updater::{ HandlerRouteInfo, update_handler_file };
use crate::build_utils::path_utils::is_dynamic_segment;
// Removed generate_handler_template as it's no longer directly called here

fn is_rust_keyword(s: &str) -> bool {
    matches!(
        s,
        "as" | "break" | "const" | "continue" | "crate" | "else" | "enum" | "extern" | "false"
            | "fn" | "for" | "if" | "impl" | "in" | "let" | "loop" | "match" | "mod" | "move"
            | "mut" | "pub" | "ref" | "return" | "self" | "Self" | "static" | "struct" | "super"
            | "trait" | "true" | "type" | "unsafe" | "use" | "where" | "while" | "async" | "await"
            | "dyn" | "abstract" | "become" | "box" | "do" | "final" | "macro" | "override"
            | "priv" | "typeof" | "unsized" | "virtual" | "yield"
    )
}

fn sanitize_module_name(name: &str) -> String {
    let sanitized = name.trim_matches(|c| (c == '[' || c == ']')).replace('-', "_");
    if is_rust_keyword(&sanitized) {
        format!("r#{}", sanitized)
    } else {
        sanitized
    }
}

pub fn generate_mod_for_directory(
  current_dir: &Path,
  root_api_path: &Path,
  all_handlers: &mut Vec<HandlerRouteInfo>,
  all_schemas: &mut HashSet<String>,
  modules: &mut Vec<String>
) -> Result<bool> {
  let mut pub_mods = Vec::new();
  let mut route_registrations = Vec::new();

  let relative_path = current_dir.strip_prefix(root_api_path).unwrap_or(Path::new(""));
  let relative_path_str = relative_path
    .to_str()
    .unwrap()
    .replace(std::path::MAIN_SEPARATOR, "::")
    .replace('-', "_");

  let module_path_prefix = if relative_path_str.is_empty() {
    "crate::routes::api".to_string()
  } else {
    let sanitized_segments: Vec<String> = relative_path_str
        .split("::")
        .map(|s| sanitize_module_name(&s.replace("[", "").replace("]", "")))
        .collect();
    format!("crate::routes::api::{}", sanitized_segments.join("::"))
  };

  let mut entries: Vec<PathBuf> = fs
    ::read_dir(current_dir)?
    .filter_map(Result::ok)
    .map(|e| e.path())
    .collect();
  entries.sort();

  for path in entries {
    let file_name = path
      .file_name()
      .and_then(|s| s.to_str())
      .unwrap_or("");
    if file_name.starts_with('.') || file_name == "mod.rs" {
      continue;
    }

    let is_dynamic = is_dynamic_segment(file_name);
    let mod_name_sanitized = sanitize_module_name(file_name);

    if path.is_dir() {
      // Create mod.rs inside the dynamic segment directory
      if is_dynamic {
        fs::write(path.join("mod.rs"), b"pub mod index;\n")?;
      }

      // Recursively generate mod.rs for the subdirectory
      let has_routes = generate_mod_for_directory(&path, root_api_path, all_handlers, all_schemas, modules)?;

      if has_routes {
        pub_mods.push(format!("pub mod {};", mod_name_sanitized));

        // Route registration for dynamic segments needs to point to the index.rs inside
        if is_dynamic {
          route_registrations.push(format!("{}::index", sanitize_module_name(&mod_name_sanitized)));
        } else {
          route_registrations.push(format!("{}", sanitize_module_name(&mod_name_sanitized)));
        }

        // If this is the root level, add to modules
        if current_dir == root_api_path {
          modules.push(mod_name_sanitized.clone());
        }
      }
    } else if path.is_file() && path.extension().map_or(false, |e| e == "rs") {
      let file_stem = path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap();

      let mod_name = sanitize_module_name(file_stem);
      pub_mods.push(format!("pub mod {};", mod_name));
      route_registrations.push(format!("{}", sanitize_module_name(&mod_name)));

      if
        let Some(handler_info) = update_handler_file(
          &path,
          all_schemas,
          &module_path_prefix,
          root_api_path
        )?
      {
        all_handlers.push(handler_info);
      }
    }
  }

  let body = if route_registrations.is_empty() {
    "router".to_string()
  } else {
    route_registrations
      .iter()
      .rev()
      .fold("router".to_string(), |acc, reg| {
          let sanitized_reg_parts: Vec<String> = reg.split("::").map(|s| sanitize_module_name(s)).collect();
          format!("{}::register_routes({})", sanitized_reg_parts.join("::"), acc)
      })
  };

  let mut_param = "";

  let mod_content = format!(
    r#"/// THIS FILE IS AUTOMATICALLY GENERATED BY build.rs
/// DO NOT EDIT THIS FILE MANUALLY

{}

/// Register routes for this directory
use axum::Router;
use std::sync::Arc;
use crate::routes::AppState;
pub fn register_routes({}router: Router<Arc<AppState>>) -> Router<Arc<AppState>> {{
  {}
}}
"#,
    pub_mods.join("\n"),
    mut_param,
    body
  );

  fs::write(current_dir.join("mod.rs"), mod_content)?;

  let has_routes = !pub_mods.is_empty();

  // If this directory has no routes and is not the root, delete it
  if !has_routes && current_dir != root_api_path {
    fs::remove_dir_all(current_dir)?;
  }

  Ok(has_routes)
}
