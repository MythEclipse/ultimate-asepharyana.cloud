use std::fs;
use std::path::Path;
use anyhow::{Result, Context};
use walkdir::WalkDir;

// This header is added by the `mod.rs` file generator to mark generated files.
const GENERATED_FILE_HEADER: &str = "// This file is generated automatically by build.rs. Do not edit it manually.";

/// Checks if a file is generated by looking for a specific header.
fn is_generated_file(path: &Path) -> Result<bool> {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read file to check for generated header: {:?}", path))?;
    Ok(content.starts_with(GENERATED_FILE_HEADER))
}

pub fn compute_directory_hash(dir: &Path) -> Result<String> {
    let mut hasher = blake3::Hasher::new();
    let mut paths = Vec::new();

    for entry in WalkDir::new(dir).into_iter().filter_map(|e| e.ok()) {
        let path = entry.path();
        if path.is_file() && path.extension().map_or(false, |e| e == "rs") {
            if let Ok(true) = is_generated_file(path) {
                continue; // Skip generated files
            }
            paths.push(path.to_path_buf());
        }
    }

    // Sort for consistent hashing
    paths.sort();

    for path in paths {
        let content = fs::read(&path).with_context(|| format!("Failed to read file for hashing: {:?}", path))?;
        hasher.update(&content);
        // Also hash modification time
        if let Ok(metadata) = fs::metadata(&path) {
            if let Ok(modified) = metadata.modified() {
                hasher.update(&modified.duration_since(std::time::UNIX_EPOCH).unwrap().as_secs().to_ne_bytes());
            }
        }
    }

    Ok(hasher.finalize().to_string())
}
