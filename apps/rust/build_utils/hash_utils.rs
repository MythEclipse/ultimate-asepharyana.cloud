use std::fs;
use std::path::Path;
use anyhow::{Result, Context};
use rayon::prelude::*;
use blake3::Hasher;

// This header is added by the `mod.rs` file generator to mark generated files.
const GENERATED_FILE_HEADER: &str = "// This file is generated automatically by build.rs. Do not edit it manually.";

/// Compute hash of all files in the API routes directory for conditional regeneration
/// Checks if a file is generated by looking for a specific header.
fn is_generated_file(path: &Path) -> Result<bool> {
    let content = fs::read_to_string(path)
        .with_context(|| format!("Failed to read file to check for generated header: {:?}", path))?;
    Ok(content.starts_with(GENERATED_FILE_HEADER))
}

pub fn compute_directory_hash(dir: &Path) -> Result<String> {
    fn collect_rs_files(dir: &Path) -> Result<Vec<std::path::PathBuf>> {
        Ok(fs::read_dir(dir)
            .with_context(|| format!("Failed to read directory for hashing: {:?}", dir))?
            .par_bridge()
            .filter_map(|entry| {
                let entry = entry.with_context(|| format!("Failed to read entry in directory: {:?}", dir));
                match entry {
                    Ok(e) => {
                        let path = e.path();
                        if path.is_dir() {
                            Some(collect_rs_files(&path))
                        } else if path.extension().map_or(false, |e| e == "rs") {
                            // Skip generated files
                            if let Ok(true) = is_generated_file(&path) {
                                None
                            } else {
                                Some(Ok(vec![path]))
                            }
                        } else {
                            None
                        }
                    },
                    Err(e) => Some(Err(e)), // Propagate errors
                }
            })
            .collect::<Result<Vec<Vec<std::path::PathBuf>>>>()?
            .into_iter()
            .flatten()
            .collect::<Vec<std::path::PathBuf>>())
    }

    let mut hasher = blake3::Hasher::new();
    let mut paths = collect_rs_files(dir)?;

    // Sort for consistent hashing
    paths.sort();

    for path in paths {
        let content = fs::read(&path).with_context(|| format!("Failed to read file for hashing: {:?}", path))?;
        hasher.update(&content);
        // Also hash modification time
        if let Ok(metadata) = fs::metadata(&path) {
            if let Ok(modified) = metadata.modified() {
                hasher.update(&modified.duration_since(std::time::UNIX_EPOCH).unwrap().as_secs().to_ne_bytes());
            }
        }
    }

    Ok(hasher.finalize().to_string())
}
