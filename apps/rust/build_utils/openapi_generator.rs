use crate::build_utils::handler_updater::HandlerRouteInfo;
use anyhow::Result;
use itertools::Itertools;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::Path;

pub fn generate_root_api_mod(
    api_routes_path: &Path,
    modules: &[String],
    all_handlers: &[HandlerRouteInfo],
    schemas: &HashSet<String>,
) -> Result<utoipa::openapi::OpenApi> {
    generate_root_api_mod_internal(api_routes_path, modules, all_handlers, schemas)
}

fn generate_root_api_mod_internal(
    api_routes_path: &Path,
    modules: &[String],
    all_handlers: &[HandlerRouteInfo],
    schemas: &HashSet<String>,
) -> Result<utoipa::openapi::OpenApi> {
    // Initialize content with header and base imports
    let mut content = String::from(
    "//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n//! DO NOT EDIT THIS FILE MANUALLY\n\n"
  );
    content.push_str("use axum::Router;\nuse std::sync::Arc;\nuse crate::routes::AppState;\n\n");

    // Add module imports
    content.push_str(&modules.iter().map(|m| format!("pub mod {};\n", m)).join(""));
    content.push('\n');

    let (imports, names) = generate_schema_imports_and_names(schemas);

    // Add schema imports to content
    content.push_str(&imports.join("\n"));
    content.push('\n');

    // Generate OpenAPI documentation with handler paths and schemas
    let handler_paths = all_handlers
        .iter()
        .map(|h| format!("              {}::{}", h.handler_module_path, h.func_name))
        .join(",\n");

    let schema_list = names
        .iter()
        .map(|s| format!("                  {}", s))
        .join(",\n");

    content.push_str(
    &format!(
      "#[derive(utoipa::OpenApi)]\n\
    #[openapi(\n\
        paths(\n{}\n        ),\n\
        components(\n            schemas(\n{}\n            )\n        ),
        security((\n            \"ApiKeyAuth\" = []\n        )),\n\
        info(\n            title = \"Freefire\",\n            version = \"0.0.1\",\n            description = \"api gratis\"\n        ),\n\
        tags(\n            (name = \"api\", description = \"Main API\")\n        )\n\
    )]\n\
    #[allow(dead_code)]\n\
    pub struct ApiDoc;\n\n",
      handler_paths,
      schema_list
    )
  );
    content.push_str(&generate_router_creation_code(modules));

    let mod_file_path = api_routes_path.join("mod.rs");
    fs::write(&mod_file_path, content)?;

    Ok({
        use utoipa::OpenApi; // Bring OpenApi trait into scope for TempApiDoc
        #[derive(utoipa::OpenApi)]
        #[openapi(paths(), components(schemas()), security(("ApiKeyAuth" = [])), tags((name = "api", description = "Main API")))]
        struct TempApiDoc;
        TempApiDoc::openapi()
    })
}

/// Generates the router creation code for the root API module.
fn generate_router_creation_code(modules: &[String]) -> String {
    let router_registrations = modules
        .iter()
        .map(|m| format!("    router = {}::register_routes(router);", m))
        .join("\n");

    let router_declaration = if modules.is_empty() {
        "    let router = Router::new();"
    } else {
        "    let mut router = Router::new();"
    };

    format!(
        "pub fn create_api_routes() -> Router<Arc<AppState>> {{\n{}\n{}\n    router\n}}\n",
        router_declaration, router_registrations
    )
}

/// Generates schema import strings and sanitized names, handling duplicates by aliasing.
fn generate_schema_imports_and_names(schemas: &HashSet<String>) -> (Vec<String>, Vec<String>) {
    let mut sorted_schemas: Vec<String> = schemas.iter().cloned().collect();
    sorted_schemas.sort();

    let mut imports = Vec::new();
    let mut names = Vec::new();
    let mut counts = HashMap::new();

    for full in sorted_schemas.iter() {
        let simple_name = full.split("::").last().unwrap().to_string();
        let count = counts.entry(simple_name.clone()).or_insert(0);
        *count += 1;

        if *count > 1 {
            let alias = format!("{} as {}_{}", full, simple_name, *count - 1);
            imports.push(format!("use {};", alias));
            names.push(format!("{}_{}", simple_name, *count - 1));
        } else {
            imports.push(format!("use {};", full));
            names.push(simple_name);
        }
    }
    (imports, names)
}
