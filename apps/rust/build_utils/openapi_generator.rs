use std::collections::{ HashMap, HashSet };
use std::fs;
use std::path::Path;
use anyhow::Result;
use itertools::Itertools;
use utoipa::OpenApi;
use crate::build_utils::handler_updater::HandlerRouteInfo;

pub fn generate_root_api_mod(
  api_routes_path: &Path,
  modules: &[String],
  all_handlers: &[HandlerRouteInfo],
  schemas: &HashSet<String>
) -> Result<utoipa::openapi::OpenApi> {
  // Initialize content with header and base imports
  let mut content = String::from(
    "//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n//! DO NOT EDIT THIS FILE MANUALLY\n\n"
  );
  content.push_str("use axum::Router;\nuse std::sync::Arc;\nuse crate::routes::AppState;\n\n");

  // Add module imports
  content.push_str(
    &modules
      .iter()
      .map(|m| format!("pub mod {};\n", m))
      .join("")
  );
  content.push_str("\n");

  let (imports, names) = generate_schema_imports_and_names(schemas);

  // Add schema imports to content
  content.push_str(&imports.join("\n"));
  content.push_str("\n");

  // Generate OpenAPI documentation with handler paths and schemas
  let handler_paths = all_handlers
    .iter()
    .map(|h| format!("              {}::{}", h.handler_module_path, h.func_name))
    .join(",\n");

  let schema_list = names
    .iter()
    .map(|s| format!("                  {}", s))
    .join(",\n");

  content.push_str(
    &format!(
      "#[derive(utoipa::OpenApi)]\n\
    #[openapi(\n\
        paths(\n{}\n        ),\n\
        components(\n            schemas(\n{}\n            )\n        ),\n\
        info(\n            title = \"Freefire\",\n            version = \"0.0.1\",\n            description = \"api gratis\"\n        ),\n\
        tags(\n            (name = \"api\", description = \"Main API\")\n        )\n\
    )]\n\
    #[allow(dead_code)]\n\
    pub struct ApiDoc;\n\n",
      handler_paths,
      schema_list
    )
  );

  // Generate router registration code
  let router_registrations = modules
    .iter()
    .map(|m| format!("    router = {}::register_routes(router);", m))
    .join("\n");

  let router_declaration = if modules.is_empty() {
    "    let router = Router::new();"
  } else {
    "    let mut router = Router::new();"
  };

  // Add router creation function
  content.push_str(
    &format!(
      "pub fn create_api_routes() -> Router<Arc<AppState>> {{\n{}\n{}\n    router\n}}\n",
      router_declaration,
      router_registrations
    )
  );

  // Write generated content to file
  fs::write(api_routes_path.join("mod.rs"), content)?;

  // Create and return OpenAPI document
  #[derive(utoipa::OpenApi)]
  #[openapi(
    paths(
      // Handlers are dynamically added above in the generated content
    ),
    components(
      schemas(
        // Schemas are dynamically added above in the generated content
      )
    ),
    tags((name = "api", description = "Main API"))
  )]
  #[allow(dead_code)]
  struct ApiDoc;

  Ok(ApiDoc::openapi())
/// Generates schema import strings and sanitized names, handling duplicates by aliasing.
fn generate_schema_imports_and_names(
    schemas: &HashSet<String>
) -> (Vec<String>, Vec<String>) {
    let mut sorted_schemas: Vec<String> = schemas.iter().cloned().collect();
    sorted_schemas.sort();

    let mut imports = Vec::new();
    let mut names = Vec::new();
    let mut counts = HashMap::new();

    for full in sorted_schemas.iter() {
        let simple_name = full.split("::").last().unwrap().to_string();
        let count = counts.entry(simple_name.clone()).or_insert(0);
        *count += 1;

        if *count > 1 {
            let alias = format!("{} as {}_{}", full, simple_name, *count - 1);
            imports.push(format!("use {};", alias));
            names.push(format!("{}_{}", simple_name, *count - 1));
        } else {
            imports.push(format!("use {};", full));
            names.push(simple_name);
        }
    }
    (imports, names)
}
}
