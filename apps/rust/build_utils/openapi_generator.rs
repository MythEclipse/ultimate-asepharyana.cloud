use std::collections::{ HashSet, BTreeMap };
use std::fs;
use std::path::Path;
use anyhow::Result;
use utoipa::openapi::{path::Operation, PathItem};
use utoipa::openapi::path::HttpMethod;
use crate::build_utils::handler_updater::HandlerRouteInfo;
use utoipa::OpenApi; // Import the OpenApi trait
use itertools::Itertools;

pub fn generate_root_api_mod(
  api_routes_path: &Path,
  modules: &[String],
  all_handlers: &[HandlerRouteInfo],
  schemas: &HashSet<String>
) -> Result<utoipa::openapi::OpenApi> {
  let mut content = String::from(
    "//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n//! DO NOT EDIT THIS FILE MANUALLY\n\n"
  );
  content.push_str(
    "use axum::Router;\nuse std::sync::Arc;\nuse crate::routes::AppState;\n\n"
  );

  for module in modules {
    content.push_str(&format!("pub mod {};\n", module));
  }
  content.push_str("\n");

  let _all_paths: BTreeMap<String, PathItem> = all_handlers
    .iter()
    .map(|h| {
        let path = h.route_path.clone();
        let http_method = h.http_method.clone();
        let operation = Operation::new(); // Placeholder for actual operation details
        let path_item = match http_method.as_str() {
            "get" => PathItem::new(HttpMethod::Get, operation),
            "post" => PathItem::new(HttpMethod::Post, operation),
            "put" => PathItem::new(HttpMethod::Put, operation),
            "delete" => PathItem::new(HttpMethod::Delete, operation),
            "patch" => PathItem::new(HttpMethod::Patch, operation),
            _ => PathItem::default(), // Fallback, though all methods should be handled
        };
        (path, path_item)
    })
    .collect();

  let mut sorted_schemas: Vec<String> = schemas.iter().cloned().collect();
  sorted_schemas.sort();

  // Generate `use` imports for each fully-qualified schema path and collect simple type names for components.
  let mut simple_names: Vec<String> = Vec::new();
  let mut use_imports = Vec::new();
  // We no longer need schema_objects: HashMap<String, Schema>
  for full in &sorted_schemas {
    let simple_name = full.split("::").last().unwrap().to_string();
    simple_names.push(simple_name.clone());
    use_imports.push(format!("use {};", full));
  }

  // Add use imports to the content
  for import in use_imports {
    content.push_str(&import);
    content.push('\n');
  }
  content.push('\n');

  // Generate the OpenAPI spec using the utoipa macro
  #[derive(utoipa::OpenApi)]
  #[openapi(
      paths(
          // Here we would list all the actual handler functions, not paths
          // For now, this will be empty, and we'll fill it in later if needed.
          // This part is typically auto-generated by utoipa for real handlers.
      ),
      components(
          schemas(
              // List of schema types that utoipa will generate from
              // This needs to be actual Rust types that derive ToSchema
              // For now, we use the collected simple_names
              // This is a placeholder, as utoipa needs actual types, not just names.
          )
      ),
      tags(
          (name = "api", description = "Main API")
      )
  )]
  #[allow(dead_code)]
  struct ApiDoc;

  let openapi_doc = ApiDoc::openapi();

  // Directly append the generated ApiDoc struct to the content
  // instead of overwriting it with a blank string.
  content.push_str(&format!(
      "#[derive(utoipa::OpenApi)]\n\
      #[openapi(\n\
          paths(\n{}\n          ),\n\
          components(\n              schemas(\n{}\n              )\n          ),\n\
          tags(\n              (name = \"api\", description = \"Main API\")\n          )\n\
      )]\n\
      #[allow(dead_code)]\n\
      pub struct ApiDoc;\n\n",
      all_handlers.iter().map(|h| format!("              {}::{}", h.handler_module_path, h.func_name)).join(",\n"),
      simple_names.iter().map(|s| format!("                  {}", s)).join(",\n")
  ));

  let router_registrations = modules
    .iter()
    .map(|m| format!("    router = {}::register_routes(router);", m))
    .collect::<Vec<_>>()
    .join("\n");

  let router_declaration = if modules.is_empty() {
    "    let router = Router::new();"
  } else {
    "    let mut router = Router::new();"
  };

  content.push_str(
    &format!("pub fn create_api_routes() -> Router<Arc<AppState>> {{\n{}\n{}\n    router\n}}\n", router_declaration, router_registrations)
  );

  fs::write(api_routes_path.join("mod.rs"), content)?;
  Ok(openapi_doc)
}
