//! Auto mod generator using route scanner.
//!
//! This module generates mod.rs files automatically based on discovered routes.

use crate::build_utils::route_scanner::scan_routes;
use crate::build_utils::handler_updater::{update_handler_file, HandlerRouteInfo};
use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

/// Generate all mod.rs files using the route scanner
pub fn generate_mods_auto(
    api_root: &Path,
    all_handlers: &mut Vec<HandlerRouteInfo>,
    all_schemas: &mut HashSet<String>,
    modules: &mut Vec<String>,
) -> Result<()> {
    // Scan all routes
    let routes = scan_routes(api_root)?;
    
    println!("cargo:warning=üìÅ Discovered {} routes", routes.len());
    
    // Group routes by directory
    let mut routes_by_dir: HashMap<PathBuf, Vec<_>> = HashMap::new();
    for route in routes {
        let dir = route.file_path.parent().unwrap_or(api_root).to_path_buf();
        routes_by_dir.entry(dir).or_default().push(route);
    }
    
    // Collect all unique directories
    let mut all_dirs: Vec<PathBuf> = routes_by_dir.keys().cloned().collect();
    all_dirs.sort();
    
    // Generate mod.rs for each directory (deepest first)
    all_dirs.reverse();
    for dir in &all_dirs {
        let dir_routes = routes_by_dir.get(dir).unwrap();
        generate_mod_for_directory_auto(
            dir,
            api_root,
            dir_routes,
            all_handlers,
            all_schemas,
            modules,
        )?;
    }
    
    Ok(())
}

/// Generate mod.rs for a single directory
fn generate_mod_for_directory_auto(
    current_dir: &Path,
    api_root: &Path,
    routes: &[crate::build_utils::types::RouteFileInfo],
    all_handlers: &mut Vec<HandlerRouteInfo>,
    all_schemas: &mut HashSet<String>,
    modules: &mut Vec<String>,
) -> Result<()> {
    let module_path_prefix = compute_module_path_prefix(current_dir, api_root)?;
    
    // Update handler files
    for route in routes {
        if let Some(handler_info) = update_handler_file(
            &route.file_path,
            all_schemas,
            &module_path_prefix,
            api_root,
        )? {
            all_handlers.push(handler_info);
        }
    }
    
    // Collect module names and pub mods
    let mut module_names: Vec<String> = Vec::new();
    let mut pub_mods: Vec<String> = Vec::new();
    
    for route in routes {
        if let Some(mod_name) = route.module_name() {
            if !module_names.contains(&mod_name) {
                module_names.push(mod_name.clone());
                pub_mods.push(format!("pub mod {};", mod_name));
            }
        }
    }
    
    // Also add subdirectories as modules
    if let Ok(entries) = fs::read_dir(current_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                let dir_name = path.file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("");
                
                // Skip hidden and private directories
                if dir_name.starts_with('.') || dir_name.starts_with('_') {
                    continue;
                }
                
                let mod_name = dir_name.replace('-', "_");
                if !module_names.contains(&mod_name) {
                    module_names.push(mod_name.clone());
                    pub_mods.push(format!("pub mod {};", mod_name));
                }
            }
        }
    }
    
    pub_mods.sort();
    module_names.sort();
    
    // Generate registration code
    let registration_code = generate_registration_code(&module_names);
    
    // Generate mod.rs content
    let mod_content = format!(
        r#"/// THIS FILE IS AUTOMATICALLY GENERATED BY build.rs
/// DO NOT EDIT THIS FILE MANUALLY

{}

/// Register routes for this directory
use axum::Router;
use std::sync::Arc;
use crate::routes::AppState;

pub fn register_routes(router: Router<Arc<AppState>>) -> Router<Arc<AppState>> {{
    {}
}}
"#,
        pub_mods.join("\n"),
        registration_code
    );
    
    // Write mod.rs
    fs::write(current_dir.join("mod.rs"), mod_content)
        .with_context(|| format!("Failed to write mod.rs for: {:?}", current_dir))?;
    
    // If this is root level API directory, add to modules list
    if current_dir == api_root {
        modules.extend(module_names);
    }
    
    Ok(())
}

fn generate_registration_code(module_names: &[String]) -> String {
    if module_names.is_empty() {
        return "router".to_string();
    }
    
    // Chain all module registrations
    module_names
        .iter()
        .rev()
        .fold("router".to_string(), |acc, name| {
            format!("{}::register_routes({})", name, acc)
        })
}

fn compute_module_path_prefix(current_dir: &Path, root_api_path: &Path) -> Result<String> {
    let relative_path = current_dir
        .strip_prefix(root_api_path)
        .unwrap_or(Path::new(""));
    
    let relative_path_str = relative_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid path encoding"))?
        .replace(std::path::MAIN_SEPARATOR, "::")
        .replace('-', "_");

    let module_path_prefix = if relative_path_str.is_empty() {
        "crate::routes::api".to_string()
    } else {
        let sanitized_segments: Vec<String> = relative_path_str
            .split("::")
            .map(|s| {
                s.trim_matches(|c| c == '[' || c == ']')
                    .replace("...", "")
                    .replace('-', "_")
            })
            .filter(|s| !s.is_empty())
            .collect();
        
        format!("crate::routes::api::{}", sanitized_segments.join("::"))
    };

    Ok(module_path_prefix)
}
