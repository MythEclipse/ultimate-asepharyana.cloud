//! Auto mod generator using route scanner.
//!
//! This module generates mod.rs files automatically based on discovered routes.

use crate::build_utils::route_scanner::scan_routes;
use crate::build_utils::route_registry::RouteRegistry;
use crate::build_utils::handler_updater::{update_handler_file, HandlerRouteInfo};
use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::Path;

/// Generate all mod.rs files using the route scanner
pub fn generate_mods_auto(
    api_root: &Path,
    all_handlers: &mut Vec<HandlerRouteInfo>,
    all_schemas: &mut HashSet<String>,
    modules: &mut Vec<String>,
) -> Result<()> {
    // Scan all routes
    let routes = scan_routes(api_root)?;
    
    println!("cargo:warning=üìÅ Discovered {} routes", routes.len());
    
    // Build registry
    let mut registry = RouteRegistry::new();
    for route in routes {
        registry.add_route(route);
    }
    
    // Get all directories
    let directories = registry.get_directories();
    
    // Generate mod.rs for each directory
    for dir_path in &directories {
        let dir = Path::new(dir_path);
        generate_mod_for_directory_auto(
            dir,
            api_root,
            &registry,
            all_handlers,
            all_schemas,
            modules,
        )?;
    }
    
    Ok(())
}

/// Generate mod.rs for a single directory using route registry
fn generate_mod_for_directory_auto(
    current_dir: &Path,
    api_root: &Path,
    registry: &RouteRegistry,
    all_handlers: &mut Vec<HandlerRouteInfo>,
    all_schemas: &mut HashSet<String>,
    modules: &mut Vec<String>,
) -> Result<()> {
    let dir_str = current_dir.to_str().unwrap_or("");
    
    // Get module names for this directory
    let module_names = registry.get_module_names(dir_str);
    
    if module_names.is_empty() {
        return Ok(());
    }
    
    // Get routes for this directory to update handler files
    let routes = registry.get_dir_routes(dir_str);
    
    // Compute module path prefix
    let module_path_prefix = compute_module_path_prefix(current_dir, api_root)?;
    
    // Update each handler file
    for route in routes {
        if let Some(handler_info) = update_handler_file(
            &route.file_path,
            all_schemas,
            &module_path_prefix,
            api_root,
        )? {
            all_handlers.push(handler_info);
        }
    }
    
    // Generate pub mod declarations
    let pub_mods: Vec<String> = module_names
        .iter()
        .map(|name| format!("pub mod {};", name))
        .collect();
    
    // Generate registration code
    let registration_code = registry.generate_registration_code(dir_str);
    
    // Generate mod.rs content
    let mod_content = format!(
        r#"/// THIS FILE IS AUTOMATICALLY GENERATED BY build.rs
/// DO NOT EDIT THIS FILE MANUALLY

{}

/// Register routes for this directory
use axum::Router;
use std::sync::Arc;
use crate::routes::AppState;

pub fn register_routes(router: Router<Arc<AppState>>) -> Router<Arc<AppState>> {{
    {}
}}
"#,
        pub_mods.join("\n"),
        registration_code
    );
    
    // Write mod.rs
    fs::write(current_dir.join("mod.rs"), mod_content)
        .with_context(|| format!("Failed to write mod.rs for: {:?}", current_dir))?;
    
    // If this is root level, add to modules list
    if current_dir == api_root {
        for name in module_names {
            modules.push(name);
        }
    }
    
    Ok(())
}

fn compute_module_path_prefix(current_dir: &Path, root_api_path: &Path) -> Result<String> {
    let relative_path = current_dir
        .strip_prefix(root_api_path)
        .unwrap_or(Path::new(""));
    
    let relative_path_str = relative_path
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid path encoding"))?
        .replace(std::path::MAIN_SEPARATOR, "::")
        .replace('-', "_");

    let module_path_prefix = if relative_path_str.is_empty() {
        "crate::routes::api".to_string()
    } else {
        let sanitized_segments: Vec<String> = relative_path_str
            .split("::")
            .map(|s| {
                s.trim_matches(|c| c == '[' || c == ']')
                    .replace("...", "")
                    .replace('-', "_")
            })
            .filter(|s| !s.is_empty())
            .collect();
        
        format!("crate::routes::api::{}", sanitized_segments.join("::"))
    };

    Ok(module_path_prefix)
}
