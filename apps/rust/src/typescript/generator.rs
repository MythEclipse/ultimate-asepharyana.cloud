//! TypeScript type generator.
//!
//! Generates TypeScript type definitions for API types.

use std::fs;
use std::path::Path;
use tracing::info;

/// Generate TypeScript type definitions.
///
/// # Example
///
/// ```ignore
/// use rust::typescript::generate_typescript_types;
///
/// generate_typescript_types("../frontend/src/types/api.d.ts")?;
/// ```
pub fn generate_typescript_types(output_path: &str) -> anyhow::Result<()> {
    info!("Generating TypeScript types to: {}", output_path);

    // Create output directory if needed
    if let Some(parent) = Path::new(output_path).parent() {
        fs::create_dir_all(parent)?;
    }

    // Generate content
    let content = generate_types_content();

    fs::write(output_path, content)?;

    info!("âœ… TypeScript types generated successfully to {}", output_path);
    Ok(())
}

/// Generate types content as a string.
pub fn generate_types_content() -> String {
    let mut content = String::from(
        "// Auto-generated by RustExpress TypeScript generator\n\
         // Do not edit manually!\n\n",
    );
    content.push_str(&format!("// Generated at: {}\n\n", chrono::Utc::now().to_rfc3339()));

    // Core types
    content.push_str(include_str!("types.ts.template"));

    // Add utility types
    content.push_str(UTILITY_TYPES);

    content
}

const UTILITY_TYPES: &str = r#"

// ============================================================================
// Utility Types
// ============================================================================

export type Result<T, E = ApiError> =
  | { ok: true; data: T }
  | { ok: false; error: E };

export type Nullable<T> = T | null;

export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// API fetch helper types
export interface FetchOptions extends RequestInit {
  baseUrl?: string;
  token?: string;
}

export type ApiMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

// Pagination types
export interface PaginationParams {
  page?: number;
  limit?: number;
  sort?: string;
  order?: 'asc' | 'desc';
}

// Validation error response
export interface ValidationError {
  error: 'Validation failed';
  code: 'VALIDATION_ERROR';
  details: Record<string, string[]>;
}

// Rate limit error response
export interface RateLimitError {
  error: 'Too many requests';
  code: 'RATE_LIMIT_EXCEEDED';
  retry_after_ms: number;
}

// Health check response
export interface HealthCheckResponse {
  status: 'ok' | 'degraded';
  version: string;
  uptime_seconds: number;
  checks?: {
    database: { status: 'ok' | 'error'; latency_ms?: number; error?: string };
    redis: { status: 'ok' | 'error'; latency_ms?: number; error?: string };
  };
}

// WebSocket message types
export type WsMessageType = 
  | 'connected'
  | 'message'
  | 'join'
  | 'leave'
  | 'error';

export interface WsMessage<T = unknown> {
  type: WsMessageType;
  payload: T;
  timestamp: string;
}
"#;
