//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs
//! DO NOT EDIT THIS FILE MANUALLY

// --- METADATA UNTUK BUILD.RS ---
const ENDPOINT_METHOD: &str = "POST";
const ENDPOINT_PATH: &str = "/api/uploader";
const ENDPOINT_DESCRIPTION: &str = "Handles file uploads.";
const ENDPOINT_TAG: &str = "uploader";
const SUCCESS_RESPONSE_BODY: &str = "UploadResponse";
// --- AKHIR METADATA ---

use axum::{
    extract::Multipart,
    response::{IntoResponse, Response},
    Json,
};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct UploadData {
    pub message: String,
    pub filename: String,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct UploadResponse {
    pub status: &'static str,
    pub data: UploadData,
}

/// Handles file uploads
#[utoipa::path(
    post,
    path = "/api/uploader",
    tag = "uploader",
    responses(
        (status = 200, description = "Success", body = UploadResponse),
        (status = 500, description = "Internal Server Error")
    )
)]
pub fn UPLOADER_HANDLER_UTOIPA() {}

pub async fn uploader_handler(mut multipart: Multipart) -> Response {
    let mut filename = String::new();
    while let Some(field) = multipart.next_field().await.unwrap() {
        filename = field.file_name().unwrap().to_string();
        let _data = field.bytes().await.unwrap();
        // Here you would typically save the file to disk or cloud storage
    }

    let response_data = UploadData {
        message: format!("File {} uploaded successfully", filename),
        filename,
    };

    let response = UploadResponse {
        status: "Ok",
        data: response_data,
    };

    Json(response).into_response()
}


pub fn register_routes(router: Router<Arc<ChatState>>) -> Router<Arc<ChatState>> {
    router.route(ENDPOINT_PATH, axum::routing::POST(uploader_handler))
}