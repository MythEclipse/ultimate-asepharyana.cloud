//! Routing module for chat application
//! All environment variables (including JWT secret) must be loaded via rust_lib::config::CONFIG_MAP

use axum::{
    routing::{get},
    Router,
    response::Redirect,
    extract::{State, WebSocketUpgrade},
    response::{IntoResponse},
};
use sqlx::MySqlPool;
use std::sync::{Arc, Mutex};
use axum::extract::ws::{Message, WebSocket};
use tokio::sync::mpsc;
use axum::Json;
use serde_json::json;
use futures::StreamExt;
use futures::SinkExt;
use tracing::info;
use crate::routes::api::chat::chat_service::{self, ChatMessage};

pub mod api; // Declare the new top-level api module

pub struct ChatState {
    pub pool: Arc<MySqlPool>,
    pub clients: Arc<Mutex<Vec<mpsc::UnboundedSender<Message>>>>,
    /// JWT secret loaded from CONFIG_MAP
    #[allow(dead_code)]
    pub jwt_secret: String,
}

pub fn create_routes() -> Router<Arc<ChatState>> {
    Router::new()
        .route("/", get(root_handler))
        .route("/ws", get(ws_handler))
        .route("/api/health", get(health_check))
        .route("/api/status", get(status_handler))
        .nest("/api", api::create_api_routes())
}

async fn root_handler() -> impl IntoResponse {
    Redirect::permanent("https://asepharyana.tech/chat")
}

// Health check endpoint
async fn health_check() -> impl IntoResponse {
    Json(json!({
        "status": "healthy",
        "service": "RustExpress",
        "version": "0.1.0",
        "timestamp": chrono::Utc::now().to_rfc3339()
    }))
}

async fn status_handler(State(state): State<Arc<ChatState>>) -> impl IntoResponse {
    // Check database connection
    let db_status = match sqlx::query("SELECT 1").execute(state.pool.as_ref()).await {
        Ok(_) => "connected",
        Err(_) => "disconnected",
    };

    Json(json!({
        "status": "running",
        "database": db_status,
        "service": "RustExpress (Rust migration of Express.js)",
        "features": ["websocket_chat", "mysql_database"]
    }))
}

async fn ws_handler(ws: WebSocketUpgrade, State(state): State<Arc<ChatState>>) -> impl IntoResponse {
    ws.on_upgrade(|socket| handle_socket(socket, state))
}

async fn handle_socket(socket: WebSocket, state: Arc<ChatState>) {
    let (mut sender, mut receiver) = socket.split();

    // Create a channel for this client
    let (tx, mut rx) = mpsc::unbounded_channel::<Message>();

    // Add the client's sender to the shared state
    state.clients.lock().unwrap().push(tx.clone());

    // Send historical messages
    if let Ok(historical_messages) = chat_service::load_messages(Arc::clone(&state.pool)).await {
        for msg in historical_messages {
            if let Ok(json_message) = serde_json::to_string(&msg) {
                if tx.send(Message::Text(json_message.into())).is_err() {
                    info!("Failed to send historical message to new client");
                    break;
                }
            }
        }
    }

    // This task forwards messages from the client's channel to the WebSocket sender
    let mut send_task = tokio::spawn(async move {
        while let Some(msg) = rx.recv().await {
            if sender.send(msg).await.is_err() {
                break;
            }
        }
    });

    // This task receives messages from the WebSocket and broadcasts them
    let recv_task_state = Arc::clone(&state);
    let mut recv_task = tokio::spawn(async move {
        while let Some(Ok(msg)) = receiver.next().await {
            match msg {
                Message::Text(text) => {
                    info!("Received message: {}", text);
                    // Parse message, save to DB, and broadcast
                    if let Ok(chat_message) = serde_json::from_str::<ChatMessage>(&text) {
                        let current_time = chrono::Utc::now();
                        let message_to_save = ChatMessage {
                            id: None, // ID will be generated by the database
                            username: chat_message.username,
                            message: chat_message.message,
                            timestamp: current_time.naive_utc(),
                        };

                        if let Err(e) = chat_service::save_message(Arc::clone(&recv_task_state.pool), &message_to_save).await {
                            info!("Failed to save message: {:?}", e);
                        }

                        // Broadcast message to all connected clients
                        chat_service::broadcast_message(message_to_save, recv_task_state.clients.clone());
                    } else {
                        info!("Failed to parse chat message: {}", text);
                    }
                }
                Message::Close(_) => {
                    break;
                }
                _ => {} // Ignore other message types like Binary, Ping, Pong
            }
        }
    });

    // Wait for either task to finish
    tokio::select! {
        _ = (&mut send_task) => recv_task.abort(),
        _ = (&mut recv_task) => send_task.abort(),
    };

    // Client disconnected, remove it from the list
    let mut clients = state.clients.lock().unwrap();
    clients.retain(|client_tx| !client_tx.same_channel(&tx));
    tracing::info!("Client disconnected, {} clients remaining.", clients.len());
}
