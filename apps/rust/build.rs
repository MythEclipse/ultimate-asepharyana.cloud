use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let api_routes_path = Path::new("src/routes/api");
    let mut modules = Vec::new();

    if api_routes_path.is_dir() {
        for entry in fs::read_dir(api_routes_path).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                if let Some(dir_name) = path.file_name().and_then(|s| s.to_str()) {
                    if dir_name != "mod" { // Exclude "mod" which is the current file's module
                        modules.push(dir_name.to_string());
                    }
                }
            } else if path.is_file() {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    if file_stem != "mod" && file_stem != "main" { // Exclude "mod" and "main.rs"
                        modules.push(file_stem.to_string());
                    }
                }
            }
        }
    }

    let mut mod_content = String::new();
    mod_content.push_str("//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n");
    mod_content.push_str("//! DO NOT EDIT THIS FILE MANUALLY\n\n");
    mod_content.push_str("use utoipa::OpenApi;\n");
    mod_content.push_str("use axum::Router;\n");
    mod_content.push_str("use crate::routes::ChatState;\n");
    mod_content.push_str("use std::sync::Arc;\n\n");

    for module in &modules {
        mod_content.push_str(&format!("pub mod {};\n", module));
    }
    mod_content.push_str("\n");

    mod_content.push_str("/// Aggregates OpenAPI docs for all API groups.\n");
    mod_content.push_str("#[derive(OpenApi)]\n");
    mod_content.push_str("#[openapi(\n");
    mod_content.push_str("    tags(\n");
    mod_content.push_str("        (name = \"api\", description = \"Root API module\")\n");
    mod_content.push_str("    ),\n");
    mod_content.push_str("    nest(\n");
    let mut nest_entries = Vec::new();
    for module in &modules {
        let pascal_case_module = module.split('_')
                  .map(|s| {
                      let mut c = s.chars();
                      match c.next() {
                          None => String::new(),
                          Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                      }
                  })
                  .collect::<String>();
        nest_entries.push(format!("        (path = \"/{}\", api = {}::{}ApiDoc)", module, module, pascal_case_module));
    }
    mod_content.push_str(&nest_entries.join(",\n"));
    mod_content.push_str("\n");
    mod_content.push_str("    )\n");
    mod_content.push_str(")]\n");
    mod_content.push_str("pub struct ApiDoc;\n\n");

    mod_content.push_str("pub fn create_api_routes() -> Router<Arc<ChatState>> {\n");
    mod_content.push_str("    let mut router = Router::new();\n");
    for module in &modules {
        mod_content.push_str(&format!("    router = router.nest(\"/{}\", {}::create_routes());\n", module, module));
    }
    mod_content.push_str("    router\n");
    mod_content.push_str("}\n");

    let out_path = Path::new("src/routes/api/mod.rs");
    fs::write(out_path, mod_content).unwrap();
    println!("cargo:rerun-if-changed=src/routes/api/");
    for module in &modules {
        println!("cargo:rerun-if-changed=src/routes/api/{}/mod.rs", module);
    }
}
