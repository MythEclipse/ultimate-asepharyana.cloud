use std::collections::HashSet;
use std::fs;
use std::path::{ Path, PathBuf };
use regex::Regex;

fn main() {
  println!("cargo:rerun-if-changed=src/routes/api/");

  let api_routes_path = Path::new("src/routes/api");
  let mut modules = Vec::new();

  if api_routes_path.is_dir() {
    if let Ok(entries) = fs::read_dir(api_routes_path) {
      for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
          if let Some(dir_name) = path.file_name().and_then(|s| s.to_str()) {
            modules.push(dir_name.to_string());
          }
        }
      }
    }
  }
  modules.sort();

  let mut all_api_docs = Vec::new();

  for module in &modules {
    println!("cargo:rerun-if-changed=src/routes/api/{}/", module);
    let module_path = api_routes_path.join(module);
    let mut handlers_set = HashSet::new(); // For Utoipa paths
    let mut schemas = HashSet::new(); // For Utoipa schemas
    let mut all_module_handler_routes = Vec::new(); // For generating create_routes

    process_module_directory(
      &module_path,
      &mut handlers_set,
      &mut schemas,
      &mut all_module_handler_routes,
      &format!("crate::routes::api::{}::", module)
    );

    if handlers_set.is_empty() {
      continue;
    }

    let pascal_case_module = to_pascal_case(module);

    let mut sorted_handlers: Vec<String> = handlers_set.into_iter().collect();
    sorted_handlers.sort();
    let mut sorted_schemas: Vec<String> = schemas.into_iter().collect();
    sorted_schemas.sort();

    // Generate OpenAPI Doc Struct
    let api_doc_struct = format!(
      "#[derive(utoipa::OpenApi)]\n#[openapi(\n    paths({}),\n    components(schemas({})),\n    tags((\n        name = \"{}\", description = \"{} endpoints\"\n    ))\n)]\npub struct {}ApiDoc;",
      all_module_handler_routes.iter().map(|info| info.full_handler_path.clone()).collect::<Vec<String>>().join(",\n        "),
      sorted_schemas.join(", "),
      module,
      module,
      pascal_case_module
    );

    all_api_docs.push((module.clone(), pascal_case_module.clone()));

    let module_mod_path = api_routes_path.join(module).join("mod.rs");

    // Generate pub mod declarations from the modules list
    let mut generated_pub_mods = String::new();
    // Assuming sub-modules are named after their directories
    for entry in fs::read_dir(&module_path).unwrap().flatten() {
        if entry.path().is_dir() {
            if let Some(dir_name) = entry.path().file_name().and_then(|s| s.to_str()) {
                // Exclude hidden directories like .vscode
                if !dir_name.starts_with('.') {
                    generated_pub_mods.push_str(&format!("pub mod {};\n", dir_name));
                }
            }
        }
    }

    // Generate create_routes function for the module
    let mut create_routes_content = String::new();
    create_routes_content.push_str("use axum::{routing::{get, post, put, delete, patch, head, options}, Router};\n");
    create_routes_content.push_str("use crate::routes::ChatState;\n");
    create_routes_content.push_str("use std::sync::Arc;\n\n");

    create_routes_content.push_str(&format!("pub fn create_routes() -> Router<Arc<ChatState>> {{\n"));
    create_routes_content.push_str("    Router::new()\n");

    // Sort handlers for consistent output
    let mut sorted_handler_routes = all_module_handler_routes.clone(); // Clone to sort
    sorted_handler_routes.sort_by(|a, b| a.api_path.cmp(&b.api_path));

    for handler_info in &sorted_handler_routes {
        let route_method = match handler_info.method.as_str() {
            "get" => "get",
            "post" => "post",
            "put" => "put",
            "delete" => "delete",
            "patch" => "patch",
            "head" => "head",
            "options" => "options",
            _ => "get", // Default to get if method is unknown
        };
        // Remove the /api/{module} prefix from the api_path to get the route segment
        let route_path_segment = handler_info.api_path.replace(&format!("/api/{}", module), "");
        create_routes_content.push_str(&format!(
            "        .route(\"{}\", {}({}))\n",
            route_path_segment,
            route_method,
            format!("{}::{}", &handler_info.full_handler_path.rsplit("::").nth(1).unwrap(), handler_info.func_name)
        ));
    }
    create_routes_content.push_str("}\n");

    // Construct the new module_mod_content
    let mut new_module_mod_content = String::new();
    new_module_mod_content.push_str("//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n");
    new_module_mod_content.push_str("//! DO NOT EDIT THIS FILE MANUALLY\n\n");

    // Add generated pub mod declarations
    new_module_mod_content.push_str(&generated_pub_mods);
    new_module_mod_content.push_str("\n");

    // Add UTOIPA DOCS block
    new_module_mod_content.push_str("// START: UTOIPA DOCS\n");
    new_module_mod_content.push_str(&api_doc_struct);
    new_module_mod_content.push_str("\n// END: UTOIPA DOCS\n\n");

    // Add API ROUTES block
    new_module_mod_content.push_str("// START: API ROUTES\n");
    new_module_mod_content.push_str(&create_routes_content);
    new_module_mod_content.push_str("\n// END: API ROUTES\n");

    fs::write(&module_mod_path, new_module_mod_content).unwrap();
  }

  generate_api_mod_file(api_routes_path, &modules, &all_api_docs);
}

// Struct to hold extracted handler information
#[derive(Debug, Clone)] // Add Clone derive
pub struct HandlerRouteInfo {
    pub func_name: String,
    pub method: String,
    pub api_path: String,
    pub params_block_parts: Vec<String>,
    pub full_handler_path: String, // Add full_handler_path field
}

fn process_module_directory(
    dir_path: &Path,
    handlers: &mut HashSet<String>,
    schemas: &mut HashSet<String>,
    all_module_handler_routes: &mut Vec<HandlerRouteInfo>,
    current_path_prefix: &str,
) {
    if let Ok(entries) = fs::read_dir(dir_path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                let sub_module_name = path
                    .file_name()
                    .and_then(|s| s.to_str())
                    .unwrap();
                process_module_directory(
                    &path,
                    handlers,
                    schemas,
                    all_module_handler_routes,
                    &format!("{}{}{}", current_path_prefix, sub_module_name, "::"),
                );
            } else if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("rs") {
                if let Some(handler_info) = update_handler_file(
                    &path,
                    handlers,
                    schemas,
                    current_path_prefix,
                ) {
                    all_module_handler_routes.push(handler_info);
                }
            }
        }
    }
}

fn update_handler_file(
    path: &PathBuf,
    handlers: &mut HashSet<String>,
    schemas: &mut HashSet<String>,
    current_path_prefix: &str,
) -> Option<HandlerRouteInfo> {
    let file_content = fs::read_to_string(path).unwrap();

    let meta_regex = Regex::new(
        r#"(?s)const\s+ENDPOINT_METHOD\s*:\s*&str\s*=\s*"([^"]*)";\s*const\s+ENDPOINT_PATH\s*:\s*&str\s*=\s*"([^"]*)";\s*const\s+ENDPOINT_DESCRIPTION\s*:\s*&str\s*=\s*"([^"]*)";\s*const\s+ENDPOINT_TAG\s*:\s*&str\s*=\s*"([^"]*)";\s*const\s+SUCCESS_RESPONSE_BODY\s*:\s*&str\s*=\s*"([^"]*)";\s*const\s+SLUG_DESCRIPTION\s*:\s*&str\s*=\s*"([^"]*)";(?P<rest_of_meta>.*?)// --- AKHIR METADATA ---"#
    ).unwrap();
    let handler_regex = Regex::new(r"pub async fn\s+([a-zA-Z0-9_]+)\s*\(").unwrap();
    let schema_regex = Regex::new(r"#\[derive\(utoipa::ToSchema\)\].*?pub struct (\w+)").unwrap();

    for cap in schema_regex.captures_iter(&file_content) {
        let schema_name = format!("{}{}", current_path_prefix, &cap[1]);
        schemas.insert(schema_name);
    }

    if let Some(meta_caps) = meta_regex.captures(&file_content) {
        if let Some(handler_caps) = handler_regex.captures(&file_content) {
            let func_name = handler_caps[1].to_string(); // Capture the actual function name
            let full_handler_path = format!("{}{}", current_path_prefix, func_name);
            handlers.insert(full_handler_path.clone());

            let method = meta_caps[1].to_lowercase();
            let api_path = &meta_caps[2];
            let description = &meta_caps[3];
            let tag = &meta_caps[4];
            let success_body = &meta_caps[5];
            let slug_description = meta_caps.get(6).map_or("", |m| m.as_str());
            let rest_of_meta = meta_caps.name("rest_of_meta").map_or("", |m| m.as_str());

            let mut params_block_parts = Vec::new();
            if api_path.contains("{slug}") {
                params_block_parts.push(format!(r#"("slug" = String, Path, description = "{}")"#, slug_description));
            }

            // Regex to capture additional const parameters
            let additional_params_regex = Regex::new(
                r#"const\s+([A-Z_]+)\s*:\s*&str\s*=\s*"([^"]*)";"#
            ).unwrap();

            for cap in additional_params_regex.captures_iter(rest_of_meta) {
                let param_name = cap[1].to_lowercase();
                let param_description = &cap[2];
                if param_name.ends_with("_description") {
                    let actual_param_name = param_name.trim_end_matches("_description");
                    if api_path.contains(&format!("{{{}}}", actual_param_name)) {
                        params_block_parts.push(format!(r#"("{} = String, Path, description = "{}")"#, actual_param_name, param_description));
                    }
                }
            }

            let params_block = if params_block_parts.is_empty() {
                "".to_string()
            } else {
                format!("params({})", params_block_parts.join(", "))
            };

            let original_declaration = format!("pub async fn {}", func_name);

            // Construct the utoipa macro content using the extracted metadata
            let utoipa_macro_content = format!(
                r#"{}, path = "{}", tag = "{}", responses((status = 200, description = "Success", body = {}), (status = 500, description = "Internal Server Error")){}"#,
                method,
                api_path,
                tag,
                success_body,
                if params_block.is_empty() { "".to_string() } else { format!(", {}", params_block) }
            ).replace(", ,", ",");

            let new_doc_block_content = format!(
                r#"/// {}
#[utoipa::path({})]"#,
                description,
                utoipa_macro_content
            );

            // Define the regex to find the existing utoipa doc block and the function declaration
            // This regex captures the potential doc block and the function declaration separately.
            let existing_doc_block_and_func_regex = Regex::new(
                &format!(r"(?s)(?P<doc_block>///.*?\n#\[utoipa::path\(.*?\)]\n)?(?P<func_decl>pub async fn {})", func_name)
            ).unwrap();

            let mut modified_content = file_content.clone();
            let mut needs_update = false;

            if let Some(caps) = existing_doc_block_and_func_regex.captures(&file_content) {
                if let Some(func_decl_match) = caps.name("func_decl") {
                    let start_byte = func_decl_match.start();

                    // Construct the new content to insert: new doc block + original function declaration
                    let new_content_to_insert = format!("{}\n{}", new_doc_block_content, original_declaration);

                    // Determine the range to replace
                    let replace_start = if let Some(doc_block_match) = caps.name("doc_block") {
                        doc_block_match.start()
                    } else {
                        start_byte
                    };
                    let replace_end = func_decl_match.end();

                    // Replace the old content with the new content
                    modified_content.replace_range(replace_start..replace_end, &new_content_to_insert);
                    needs_update = true;
                }
            } else {
                // If no existing block was found, simply insert the new block before the function
                if let Some(func_match) = file_content.find(&original_declaration) {
                    modified_content.replace_range(
                        func_match..func_match + original_declaration.len(),
                        &format!("{}\n{}", new_doc_block_content, original_declaration)
                    );
                    needs_update = true;
                }
            }

            if needs_update {
                fs::write(path, modified_content).unwrap();
            }

            return Some(HandlerRouteInfo {
                func_name,
                method,
                api_path: api_path.to_string(),
                params_block_parts,
                full_handler_path: full_handler_path.clone(),
            });
        }
    }
    None
}

fn generate_api_mod_file(
    api_routes_path: &Path,
    modules: &[String],
    all_api_docs: &[(String, String)],
) {
    let mut mod_content = String::new();
    mod_content.push_str("//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n");
    mod_content.push_str("//! DO NOT EDIT THIS FILE MANUALLY\n\n");

    mod_content.push_str("use axum::Router;\n");
    mod_content.push_str("use std::sync::Arc;\n");
    mod_content.push_str("use utoipa::OpenApi;\n");
    mod_content.push_str("use crate::routes::ChatState;\n\n");

    for module in modules {
        mod_content.push_str(&format!("pub mod {};\n", module));
    }
    mod_content.push_str("\n");

    mod_content.push_str("#[derive(OpenApi)]\n#[openapi(\n");
    let nest_entries: Vec<String> = all_api_docs
        .iter()
        .map(|(module, pascal_case)| {
            format!("        (path = \"/api/{}\", api = {}::{}ApiDoc)", module, module, pascal_case)
        })
        .collect();

    if !nest_entries.is_empty() {
        mod_content.push_str("    nest(\n");
        mod_content.push_str(&nest_entries.join(",\n"));
        mod_content.push_str("\n    ),\n");
    }

    mod_content.push_str(
        "    paths(),\n    components(),\n    tags((\n        name = \"api\", description = \"Main API\"\n    ))\n"
    );
    mod_content.push_str(")]\npub struct ApiDoc;\n\n");

    mod_content.push_str("pub fn create_api_routes() -> Router<Arc<ChatState>> {\n");
    let router_content = modules
        .iter()
        .map(|m| format!("        .nest(\"/{}\", {}::create_routes())", m, m))
        .collect::<Vec<_>>()
        .join("\n");
    if router_content.is_empty() {
        mod_content.push_str("    Router::new()\n");
    } else {
        mod_content.push_str("    Router::new()\n");
        mod_content.push_str(&router_content);
        mod_content.push_str("\n");
    }
    mod_content.push_str("}\n");

    let out_path = api_routes_path.join("mod.rs");
    fs::write(out_path, mod_content).unwrap();
}

fn to_pascal_case(s: &str) -> String {
  s.split('_')
    .map(|word| {
      let mut c = word.chars();
      match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
      }
    })
    .collect()
}
