use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let api_routes_path = Path::new("src/routes/api");
    let mut modules = Vec::new();

    if api_routes_path.is_dir() {
        for entry in fs::read_dir(api_routes_path).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                if let Some(dir_name) = path.file_name().and_then(|s| s.to_str()) {
                    if dir_name != "mod" { // Exclude "mod" which is the current file's module
                        modules.push(dir_name.to_string());
                    }
                }
            } else if path.is_file() {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    if file_stem != "mod" && file_stem != "main" { // Exclude "mod" and "main.rs"
                        modules.push(file_stem.to_string());
                    }
                }
            }
        }
    }

    let mut mod_content = String::new();
    mod_content.push_str("//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n");
    mod_content.push_str("//! DO NOT EDIT THIS FILE MANUALLY\n\n");
    mod_content.push_str("use utoipa::OpenApi;\n");
    mod_content.push_str("use axum::Router;\n");
use std::collections::HashMap;
use regex::Regex;

    mod_content.push_str("use crate::routes::ChatState;\n");
    mod_content.push_str("use std::sync::Arc;\n\n");

    let mut module_api_docs = HashMap::new();

    for module in &modules {
        mod_content.push_str(&format!("pub mod {};\n", module));

        let module_mod_path = format!("src/routes/api/{}/mod.rs", module);
        let module_mod_content = fs::read_to_string(&module_mod_path)
            .unwrap_or_else(|_| panic!("Failed to read {}", module_mod_path));

        let pascal_case_module = module.split('_')
            .map(|s| {
                let mut c = s.chars();
                match c.next() {
                    None => String::new(),
                    Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                }
            })
            .collect::<String>();

        // Regex to find .route("/path", ...) calls and extract handler functions
        let route_regex = Regex::new(r#"\.route\("([^"]*)",\s*(?:get|post|put|delete|patch)\(([^)]*)\)\)"#).unwrap();
        let mut handlers = Vec::new();

        for cap in route_regex.captures_iter(&module_mod_content) {
            handlers.push(cap[2].to_string()); // Capture the handler function name
        }

        let mut api_doc_struct_content = String::new();
        api_doc_struct_content.push_str("/// Auto-generated OpenAPI documentation for this module.\n");
        api_doc_struct_content.push_str("#[derive(utoipa::OpenApi)]\n");
        api_doc_struct_content.push_str("#[openapi(\n");
        api_doc_struct_content.push_str("    paths(\n");
        let formatted_handlers: Vec<String> = handlers.iter()
            .map(|h| format!("        {}", h))
            .collect();
        api_doc_struct_content.push_str(&formatted_handlers.join(",\n"));
        api_doc_struct_content.push_str("\n    )\n");
        api_doc_struct_content.push_str(")]\n");
        api_doc_struct_content.push_str(&format!("pub struct {}ApiDoc;\n", pascal_case_module));

        module_api_docs.insert(module.to_string(), api_doc_struct_content);

        // Remove KILOKODE_OPENAPI_PATHS comment
        let regex_comment = Regex::new(r"// KILOKODE_OPENAPI_PATHS:.*?\n").unwrap();
        module_mod_content = regex_comment.replace_all(&module_mod_content, "").to_string();

        // Append the generated ApiDoc struct to the module's mod.rs file
        module_mod_content.push_str("\n"); // Add a newline for separation
        module_mod_content.push_str(module_api_docs.get(module).unwrap()); // Use .get(module).unwrap() for the correct content

        fs::write(&module_mod_path, module_mod_content).unwrap();
    }
    mod_content.push_str("\n");

    mod_content.push_str("/// Aggregates OpenAPI docs for all API groups.\n");
    mod_content.push_str("#[derive(OpenApi)]\n");
    mod_content.push_str("#[openapi(\n");
    mod_content.push_str("    tags(\n");
    mod_content.push_str("        (name = \"api\", description = \"Root API module\")\n");
    mod_content.push_str("    ),\n");
    mod_content.push_str("    nest(\n");
    let mut nest_entries = Vec::new();
    for module in &modules {
        let pascal_case_module = module.split('_')
                  .map(|s| {
                      let mut c = s.chars();
                      match c.next() {
                          None => String::new(),
                          Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
                      }
                  })
                  .collect::<String>();
        nest_entries.push(format!("        (path = \"/{}\", api = {}::{}ApiDoc)", module, module, pascal_case_module));
    }
    mod_content.push_str(&nest_entries.join(",\n"));
    mod_content.push_str("\n");
    mod_content.push_str("    )\n");
    mod_content.push_str(")]\n");
    mod_content.push_str("pub struct ApiDoc;\n\n");

    mod_content.push_str("pub fn create_api_routes() -> Router<Arc<ChatState>> {\n");
    mod_content.push_str("    let mut router = Router::new();\n");
    for module in &modules {
        mod_content.push_str(&format!("    router = router.nest(\"/{}\", {}::create_routes());\n", module, module));
    }
    mod_content.push_str("    router\n");
    mod_content.push_str("}\n");

    let out_path = Path::new("src/routes/api/mod.rs");
    fs::write(out_path, mod_content).unwrap();
    println!("cargo:rerun-if-changed=src/routes/api/");
    for module in &modules {
        println!("cargo:rerun-if-changed=src/routes/api/{}/mod.rs", module);
    }
}
