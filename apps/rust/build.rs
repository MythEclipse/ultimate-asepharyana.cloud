use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let api_routes_path = Path::new("src/routes/api");
    let mut modules = Vec::new();

    if api_routes_path.is_dir() {
        for entry in fs::read_dir(api_routes_path).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                if let Some(dir_name) = path.file_name().and_then(|s| s.to_str()) {
                    if dir_name != "mod" { // Exclude "mod" which is the current file's module
                        modules.push(dir_name.to_string());
                    }
                }
            } else if path.is_file() {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    if file_stem != "mod" && file_stem != "main" { // Exclude "mod" and "main.rs"
                        modules.push(file_stem.to_string());
                    }
                }
            }
        }
    }

    let mut mod_content = String::new();
    mod_content.push_str("//! THIS FILE IS AUTOMATICALLY GENERATED BY build.rs\n");
    mod_content.push_str("//! DO NOT EDIT THIS FILE MANUALLY\n\n");
    mod_content.push_str("use utoipa::OpenApi;\n");
    mod_content.push_str("use axum::Router;\n");
    mod_content.push_str("use crate::routes::ChatState;\n");
    mod_content.push_str("use std::sync::Arc;\n\n");

    let mut openapi_paths = Vec::new();

    for module in &modules {
        mod_content.push_str(&format!("pub mod {};\n", module));
        let module_mod_path = api_routes_path.join(module).join("mod.rs");
        if let Ok(content) = fs::read_to_string(&module_mod_path) {
            for line in content.lines() {
                if line.trim().starts_with("// KILOKODE_OPENAPI_PATHS:") {
                    let paths_str = line.trim_start_matches("// KILOKODE_OPENAPI_PATHS:").trim();
                    for path in paths_str.split(',') {
                        let trimmed_path = path.trim();
                        if !trimmed_path.is_empty() {
                            openapi_paths.push(format!("        \"{}\"", trimmed_path));
                        }
                    }
                }
            }
        }
    }
    mod_content.push_str("\n");

    mod_content.push_str("/// Aggregates OpenAPI docs for all API groups.\n");
    mod_content.push_str("#[derive(OpenApi)]\n");
    mod_content.push_str("#[openapi(\n");
    mod_content.push_str("    tags(\n");
    mod_content.push_str("        (name = \"api\", description = \"Root API module\")\n");
    mod_content.push_str("    ),\n");
    mod_content.push_str("    paths(\n");
    mod_content.push_str(&openapi_paths.join(",\n"));
    mod_content.push_str("\n");
    mod_content.push_str("    )\n");
    mod_content.push_str(")]\n");
    mod_content.push_str("pub struct ApiDoc;\n\n");

    mod_content.push_str("pub fn create_api_routes() -> Router<Arc<ChatState>> {\n");
    mod_content.push_str("    let mut router = Router::new();\n");
    for module in &modules {
        mod_content.push_str(&format!("    router = router.merge({}::create_routes());\n", module));
    }
    mod_content.push_str("    router\n");
    mod_content.push_str("}\n");

    let out_path = Path::new("src/routes/api/mod.rs");
    fs::write(out_path, mod_content).unwrap();
    println!("cargo:rerun-if-changed=src/routes/api/");
    for module in &modules {
        println!("cargo:rerun-if-changed=src/routes/api/{}/mod.rs", module);
    }
}
